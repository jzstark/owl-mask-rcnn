module N = Owl.Dense.Ndarray.S

type image_meta = {
    image_id             : int;
    original_image_shape : int array;
    image_shape          : int array;
    window               : int array;
    scale                : float;
    active_class_ids     : int array;
  }

val preprocess : N.arr -> N.arr
(** [preprocess img] returns a new image whose colours has been shifted by the
 ** recommended amount to evaluate it with ResNet. *)

val postprocess : N.arr -> N.arr
(** Inverse operation of [preprocess]. *)

val save : string -> Images.format -> Images.t -> unit
(** [save dest format img] saves a Camlimage [img] as a file to the specified
 ** destination [dest]. *)

val img_of_ndarray : N.arr -> Images.t
(** [img_of_ndarray arr] converts an Ndarray [arr] to a Camlimages' image. *)

val img_to_ndarray : string -> N.arr
(** [img_to_ndarray src] transforms an image file to an Ndarray of dimension
 ** (H, W, 3), RGB. Only supports RGB24 image formats. *)

val resize : ?h:int -> ?w:int -> string -> N.arr * int array * int array * float
(** [resize ~h ~w src] converts the [src] file to an Ndarray of colors RGB and
 ** resize it to [h, w] size. Keeps the original scale and pads with 0's if
 ** necessary. Returns the resized image, its shape, the position of the image
 ** inside the array (excluding the padding) and the scale of the resizing. *)

val parse_image_meta : N.arr -> image_meta
(** [parse_image_meta meta] parses information about the image as a sequential
 ** Ndarray and returns an image_meta instance. Assumes a batch size of 1. *)

val mold_inputs : string -> N.arr * N.arr * int array
(** [mold_inputs src] processes an image file to be Mask R-CNN ready. Returns
 ** the processed image, information about the resizing and the position of the
 ** image inside the Ndarray.*)

val apply_box_deltas : N.arr -> N.arr -> N.arr
(** [apply_box_deltas boxes deltas] applies the deltas to the boxes.
 ** [boxes]: [N, (y1, x1, y2, x2)],
 ** [deltas]: [N, (dx, dy, log(dh), log(dy))]. *)

val clip_boxes : N.arr -> N.arr -> N.arr
(** [clip_boxes boxes window] clips the [boxes] to fit inside the [window].
 ** [boxes]: [N, (y1, x1, y2, x2)], window: (y1, x1, y2, x2). *)

val norm_boxes : N.arr -> int array -> N.arr
(** [norm_boxes boxes shape] converts the [boxes] from pixel coordinates to
 ** normalised coordinates inside [shape].
 ** boxes: [N, (y1, x1, y2, x2)], shape: (h, w). *)

val denorm_boxes : N.arr -> int array -> N.arr
(** [denorm_boxes boxes shape] performs the inverse operation of
 ** [norm_boxes]. *)

val intersection_over_union : float array -> float array -> float
(** [intersection_over_union box1 box2] returns the area of the intersection of
 ** [box1] and [box2] divided by the area of their union. Used to avoid
 ** selecting the same object multiple times with closely overlapping bounding
 ** boxes. *)

val non_max_suppression : N.arr -> N.arr -> int -> float -> int array
(** [non_max_suppression boxes scores max_output_size iou_threshold] greedily
 ** selects the indices of the boxes with the highest score that don't have an
 ** [intersection_over_union] greater than [iou_threshold] with each
 ** other. Selects at most [max_output_size] boxes.
 ** [boxes]: [N, (y1, x1, y2, x2)], [scores]: [N]. *)

val crop_and_resize : N.arr -> N.arr -> int array -> N.arr
(** For each box in [boxes], [crop_and_resize image boxes crop_shape] crops the
 ** box out of [image] and resizes it to [crop_shape] using bilinear
 ** interpolation. The boxes should be in normalised coordinates.
 ** Returns a tensor of shape [num_boxes, crop_shape[0], crop_shape[1], depth].
 ** Algorithm ported from https://github.com/tensorflow/tensorflow/blob/
 ** master/tensorflow/core/kernels/crop_and_resize_op.cc#L202. *)

val get_anchors : int array -> N.arr
(** [get_anchors image_shape] generates anchors to use as an input of Mask
 ** R-CNN, given the shape of the input image. *)

val unmold_mask : N.arr -> N.arr -> N.arr * int * int * int * int
(** [unmold_mask mask box] converts a mask generated by Mask R-CNN to its format
 ** on the image. *)

val unmold_detections : N.arr -> N.arr -> int array -> int array -> int array
                        -> N.arr * int array * N.arr
                           * (int -> N.arr * int * int * int * int)
(** [unmold_detections detections masks orig_shape shape window] reformats the
 ** results of the Mask R-CNN network to a more suitable format.
 ** Inputs:
 **   [detections]: [N, (y1, x1, y2, x2, class_id, score)],
 **   [mrcnn_mask]: [N, height, width, num_classes],
 **   [original_shape]: (H, W, C),
 **   [image_shape]: (H, W, C),
 **   [window]: (y1, x1, y2, x2).
 ** Outputs:
 **   boxes: [N, (y1, x1, y2, x2)], class_ids: [N],
 **   scores: [N], masks: int -> [H, W] * (y1, x1, y2, x2). *)
